‍

---

# 1 浮点数

Python 中出现一个有趣的状况

```python
>>> 0.1
0.1000000000000001
>>> 0.1+0.2
0.30000000000000004
```

为什么这样？见文中：

> 这是因为语言绝大多数C语言的双精度实现都遵守IEEE754规范，其中52位用于底。因此浮点值只能有52位精度，类似这样的值用二进制表示只能像上面那样被截断。0.1的二进制表示是0.11001100110011…\*2^-3，因为它最接近的二进制近似值是0.0001100110011…，或1/16+1/32+1/256+…

so 0.1 为什么输出为 0.1000000000000001 ？

***第一步，先把0.1转成二进制***

整数转二进制大家肯定都知道的，这个就不说了，但是小数部分怎么转可能还是有些同学不知道。没关系，附上链接：[二进制十进制间小数怎么转换](http://jingyan.baidu.com/article/425e69e6e93ca9be15fc1626.html)

所以十进制0.1的二进制就是0.00011001100110011…到这里，

> 0.1的二进制表示是0.11001100110011…*2^-3

这句话就懂了吧。

***第二步，大概了解下IEEE 754***

IEEE 754 标准是IEEE二进位浮点数算术标准（IEEE Standard for Floating-Point Arithmetic）的标准编号，IEEE 754 标准规定了计算机程序设计环境中的二进制和十进制的浮点数自述的交换、算术格式以及方法。

> 根据国际标准IEEE 754，任意一个二进制浮点数V可以表示成下面的形式：
>
> $$
> V=(-1)^s*M*2^E
> $$
>
> ```
> （1）(-1)^s表示符号位，当s=0，V为正数；当s=1，V为负数。
>
> （2）M表示有效数字，大于等于1，小于2。
>
> （3）2^E表示指数位。
> ```

举例来说，十进制的5.0，写成二进制是101.0，相当于1.01×2^2。那么，按照上面V的格式，可以得出s=0，M=1.01，E=2。

十进制的-5.0，写成二进制是-101.0，相当于-1.01×2^2。那么，s=1，M=1.01，E=2。

IEEE 754规定，对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。 
![[Pasted image 20241015083240.png]]  
对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。 
![[Pasted image 20241015083257.png]]

IEEE 754对有效数字M和指数E，还有一些特别规定。

前面说过，1≤M<2，也就是说，M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分。IEEE 
754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。

至于指数E，情况就比较复杂。

首先，E为一个无符号整数（unsigned   int）。这意味着，如果E为8位，它的取值范围为0\~255；如果E为11位，它的取值范围为0\~2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE754规定，E的真实值必须再减去一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。

比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。

然后，指数E还可以再分成三种情况：

（1）E不全为0或不全为1。这时，浮点数就采用上面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。

（2）E全为0。这时，浮点数的指数E等于1-127（或者1-1023），有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。

（3）E全为1。这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；如果有效数字M不全为0，表示这个数不是一个数（NaN）。

***第三步，把十进制0.1用32位bit位表示***

0.1的二进制是1.100110011001100110011001…*2^-4 
根据公式 $V=(-1)^s*M*2^E$  

正数符号位为0；省略第一位的1，M为100110011001100110011001；E=-4+127=123，二进制表示为

> 可以得出 s=0，M=100 1100 1100 1100 1100 1100，E=0111 1011

所以写成二进制形式是 
0 10011001100110011001100 01111011

***第四步，把前两步都忘了然后把二进制转回十进制***

这个怎么转回10进制呢？刚刚十进制转二进制是乘2得出每一位，那现在就是反过来，每一位除以2加起来就是了。 
刚刚说的0.1的二进制

> 0.0001100110011…

转回十进制大概是这样

> 1\*\(2\^-4\)+1\*\(2\^-5\)+1\*\(2\^-8\)+1\*\(2\^-9\)+1\*\(2\^-11\)+…

算出来的结果应该就是0.1000000000000001，也就是结论了。 
有耐心的你去验证下，反正我没耐心算。

[（转）从Python的0.1输出0.1000000000000001说浮点数的二进制 - mofy - 博客园](https://www.cnblogs.com/z-books/p/6909962.html)
